<!doctype html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hexo</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/styles/tomorrow-night.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
    <header>
    <span class="banner"><a href="/">Hexo</a></span>
    <span class="menu">Menu</span>
    <ul class="menu_list hide">
        
            <li><a href="/">Home</a></li>
        
            <li><a href="/archives">Archives</a></li>
        
            <li><a href="/tags">Tags</a></li>
        
            <li><a href="/links">Links</a></li>
        
            <li><a href="/about">About</a></li>
        
    </ul>
</header>
    <div class="main">
        
    <article>
    <h1 class="post-title">
        <span>CORS请求头&amp;&amp;响应头概览</span>
    </h1>
    <section class="post-content">
        
            
        
        <p>最近项目中遇到了跨域传Cookie的问题，在之前对于CORS的响应头只接触过<code>Access-Control-Allow-Origin</code>，其实除此之外还有很多跨域相关的请求头和响应头，在这整理一下。</p>
<a id="more"></a>
<p>文中的例子一共涉及两个工程，一个 <code>cors-client</code> 服务在本地 8080 端口，一个 <code>cors-server</code> 在本地 3000 端口，分别用来发送请求和处理请求。HTTP请求库使用<code>axios</code>，服务是<code>express</code>搭建的简单服务器。</p>
<h2 id="Access-Control-Allow-Origin"><a href="#Access-Control-Allow-Origin" class="headerlink" title="Access-Control-Allow-Origin"></a>Access-Control-Allow-Origin</h2><p>这是最常见的响应头，表示请求的资源能共享给哪些域。同源安全策略默认阻止跨域获取资源。如果直接发起跨域请求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; code &#125; = <span class="keyword">await</span> axios.post(<span class="string">'http://localhost:3000/api/demo'</span>);</span><br></pre></td></tr></table></figure>
<p>浏览器会报跨域错误：</p>
<p><img src="https://s2.ax1x.com/2019/09/10/naljFH.png" alt></p>
<p>因为没有 <code>Access-Control-Allow-Origin</code> 响应头，如果在服务端允许本地 8000 端口跨域访问：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">'/api/demo'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'http://localhost:8080'</span>)</span><br><span class="line">  res.json(&#123;<span class="attr">code</span>: <span class="number">200</span>, <span class="attr">message</span>: <span class="string">'Hello~'</span>&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们就能顺利访问到资源了 ，同时可以看到 Response Headers 里的  <code>Access-Control-Allow-Origin</code>，就是我们 client 的域：</p>
<p><img src="https://s2.ax1x.com/2019/09/10/na1im8.png" alt></p>
<p>除此之外，还可以设置成 <code>*</code> 表示资源可以被任何域共享。</p>
<h2 id="Access-Control-Allow-Headers"><a href="#Access-Control-Allow-Headers" class="headerlink" title="Access-Control-Allow-Headers"></a>Access-Control-Allow-Headers</h2><p>这个请求头用于响应<strong>预请求</strong>，告知实际的请求中可以使用哪些 HTTP 头。不过预请求只有在复杂请求时才会发，复杂请求与简单请求相对，简单请求满足以下条件：</p>
<ol>
<li><p>request header 是简单的请求头：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type<br>等等非自定义的请求头</li>
</ul>
</li>
<li><p>request method 是下面的请求类型：</p>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
</li>
<li><p>Content-Type 只限三个值：</p>
<ul>
<li>application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
</li>
</ol>
<p>否则就是复杂请求, (实际上xhr绑定了<code>onloadStart</code>事件，body有值等也发送了 options 请求）。比如我们通常会在请求头里加上 <code>x-requested-with</code>，用来区分请求是否是ajax请求，这时请求就变成了一个复杂请求，刷新浏览器，可以在浏览器里发现浏览器没有立刻发出post请求，而是发送了一个options请求：</p>
<p><img src="https://s2.ax1x.com/2019/09/11/na3CC9.png" alt></p>
<p>可以看到 request headers 里有 <code>Origin</code>，<code>Access-Control-Request-Method</code>, <code>Access-Control-Request-Headers</code>，有了这些信息，我们就可以对客户端想要发起的复杂请求的信息校验，进而决定是否允许真正的请求发送到服务端。其中：</p>
<ul>
<li><code>Origin</code> 表示请求是从什么域发起的</li>
<li><code>Access-Control-Request-Headers</code>告知正式请求会用哪些请求头</li>
<li><code>Access-Control-Request-Method</code> 告知服务器正式请求的方法</li>
</ul>
<p><code>Access-Control-Allow-Headers</code> 告知正式请求中允许携带的请求头，简单的请求头，如 <code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Content-Type</code> （只限于解析后的值为 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code> 或 <code>text/plain</code> 三种MIME类型（不包括参数））是始终被支持的，不需要特意列出。如果客户端发送了其他 <code>Access-Control-Allow-Headers</code> 中没有列出的头，就会被CORS策略限制，比如我们在请求头中加入 <code>x-requested-with</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resp = <span class="keyword">await</span> axios.post(<span class="string">'http://localhost:3000/api/demo'</span>, &#123;&#125;, &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果服务端没有做任何处理，浏览器就会报错：</p>
<p><img src="https://s2.ax1x.com/2019/09/11/na33KP.png" alt></p>
<p>在服务端增加处理预检请求逻辑，增加 <code>Access-Control-Allow-Headers</code> 响应头：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.options(<span class="string">'*'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'http://localhost:8080'</span>)</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'x-requested-with'</span>);</span><br><span class="line">    res.end(<span class="string">''</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样在预检请求通过后，发送正式请求时就可以携带 <code>X-Requested-With</code> 请求头。</p>
<h2 id="Access-Control-Expose-Headers"><a href="#Access-Control-Expose-Headers" class="headerlink" title="Access-Control-Expose-Headers"></a>Access-Control-Expose-Headers</h2><p>这个响应头和 <code>Access-Control-Allow-Headers</code> 相反，<code>Access-Control-Allow-Headers</code> 表示客户端能携带什么请求头给服务端，<code>Access-Control-Expose-Headers</code> 表示服务端能暴露什么响应头给客户端。比如在服务端响应接口时通过<code>res.header</code>添加了自定义的响应头<code>validate-token</code>，如果没有添加 <code>Access-Control-Expose-Headers</code> 头，即使在浏览器调试工具里可以看到<code>validate-token</code>确实被返回了，但无法通过js获取到值。只有在服务端设置了响应头，才能在客户端代码中拿到对应响应头的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line">app.post(<span class="string">'/api/demo'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'http://localhost:8080'</span>)</span><br><span class="line">  res.header(<span class="string">'Access-Control-Expose-Headers'</span>, <span class="string">'validate-token'</span>);</span><br><span class="line">  res.header(<span class="string">'validate-token'</span>, <span class="string">'token-value'</span>);</span><br><span class="line">  res.json(&#123;<span class="attr">code</span>: <span class="number">200</span>, <span class="attr">message</span>: <span class="string">'Hello~'</span>&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// client</span></span><br><span class="line"><span class="keyword">const</span> resp = <span class="keyword">await</span> axios.post(<span class="string">'http://localhost:3000/api/demo'</span>, &#123;&#125;, &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(resp.headers[<span class="string">'validate-token'</span>]); <span class="comment">// token-value</span></span><br></pre></td></tr></table></figure>
<h2 id="Access-Control-Max-Age"><a href="#Access-Control-Max-Age" class="headerlink" title="Access-Control-Max-Age"></a>Access-Control-Max-Age</h2><p>表示预检请求的返回结果（即 Access-Control-Allow-Methods 和Access-Control-Allow-Headers 提供的信息）可以被缓存多久，单位是秒。在Firefox中，上限是24小时 （即86400秒），而在Chromium 中则是10分钟（即600秒）。Chromium 同时规定了一个默认值 5 秒。如果值为 -1，则表示禁用缓存。如果没有特殊逻辑的话，预检请求基本都是直接通过，所以如果没有特殊需求，这个响应头的值可以设置得大一些，另外自己验证这个响应头的功能时记得吧 Chrome 里的 <code>Disable Cache</code> 关掉。</p>
<h2 id="Origin"><a href="#Origin" class="headerlink" title="Origin"></a>Origin</h2><p>表明获取资源的请求是从什么域发起的。</p>
<h2 id="Access-Control-Allow-Credentials"><a href="#Access-Control-Allow-Credentials" class="headerlink" title="Access-Control-Allow-Credentials"></a>Access-Control-Allow-Credentials</h2><p>这也是一个很重要的响应头，指示当请求是凭证模式（Request.credentials = ‘include’）时，是否响应该请求。<br>Credentials 可以是 cookies, authorization headers 或 TLS client certificates。其中 Cookie 是最常见的。</p>
<p><code>Access-Control-Allow-Credentials</code> 头要和 <code>XMLHttpRequest.withCredentials</code> 或 <code>Fetch API中的Request()</code> 构造器中的 <code>credentials</code> 选项结合使用。Credentials 必须在前后端都被配置（即the Access-Control-Allow-Credentials header 和 XHR 或Fetch request中都要配置）才能使带 <code>credentials</code> 的CORS请求成功。</p>
<p>举个例子，如果想在跨域请求带上 Cookie，以 <code>axios</code> 为例，客户端首先要设置 <code>withCredentials: true</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resp = <span class="keyword">await</span> axios.post(<span class="string">'http://localhost:3000/api/demo'</span>, &#123;&#125;, &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    withCredentials: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>同时，服务端也要设置 <code>Access-Control-Allow-Credentials</code>，这里 options 和 正式请求都要设置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.options(<span class="string">'*'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'http://localhost:8080'</span>);</span><br><span class="line">    res.header(<span class="string">'Access-Control-Max-Age'</span>, <span class="number">60</span>);</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'content-type,x-requested-with'</span>);</span><br><span class="line">    res.header(<span class="string">'Access-Control-Expose-Headers'</span>, <span class="string">'validate-token'</span>);</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Credentials'</span>, <span class="literal">true</span>);</span><br><span class="line">    res.end(<span class="string">''</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">'/api/demo'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'[COOKIE]'</span>, req.headers.cookie)</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'http://localhost:8080'</span>)</span><br><span class="line">    res.header(<span class="string">'Access-Control-Expose-Headers'</span>, <span class="string">'validate-token'</span>);</span><br><span class="line">    res.header(<span class="string">'validate-token'</span>, <span class="string">'token-value'</span>);</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Credentials'</span>, <span class="literal">true</span>);</span><br><span class="line">    res.json(&#123;<span class="attr">code</span>: <span class="number">200</span>, <span class="attr">message</span>: <span class="string">'Hello~'</span>&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>刷新浏览器发送请求，服务端就能在跨域的情况加接收到 Cookie：</p>
<p><img src="https://s2.ax1x.com/2019/09/12/nwI0lF.png" alt></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>CORS</code>是通过传输的HTTP头组成的一个系统，用来决定浏览器是否要阻止跨域请求的响应。一般情况下，只需要设置 <code>Access-Control-Allow-Origin</code> 就能解决一大半的场景；如果需要携带自定义的请求头，响应头，就要用到 <code>Access-Control-Allow-Headers</code> 和 <code>Access-Control-Expose-Headers</code> 了；<code>Access-Control-Request-Header</code> 和 <code>Access-Control-Request-Method</code>，<code>Origin</code> 无需设置，浏览器会自动带上，在进行自定义校验时可能会派上用场；如果想要在跨域请求头携带认证信息，就一定要设置 <code>Access-Control-Allow-Credentials</code> 响应头，客户端也要启用认证模式。</p>
<p>跨域的问题还是很好解决的，因为当JS代码因为同源策略被阻塞时，浏览器给出的错误提示已经足够详细了，只要根据错误信息修改头信息就能万事大吉了~</p>

    </section>
    
        <section id="comments">
        
        </section>
    
</article>

    </div>
    <button class="feedback-btn" data-feedbackok-trigger>Hello~ 🥰</button>
    <footer>
    <div class="info"><span>Powered By <a href="https://hexo.io/" target="blank">Hexo</a></span>&nbsp;&nbsp;&nbsp;&nbsp;<span>Theme by <a href="https://github.com/showonne/hexo_showonne" target="blank">Showonne</a></span></div>
</footer>
    <script src="https://cdn.feedbackok.com/widget.js" data-pid="0m524p3" async defer></script>
    <script src="/js/index.js"></script>
</body>
</html>
