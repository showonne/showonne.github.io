<!doctype html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hexo</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/styles/tomorrow-night.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
    <header>
    <span class="banner"><a href="/">Hexo</a></span>
    <span class="menu">Menu</span>
    <ul class="menu_list hide">
        
            <li><a href="/">Home</a></li>
        
            <li><a href="/archives">Archives</a></li>
        
            <li><a href="/tags">Tags</a></li>
        
            <li><a href="/links">Links</a></li>
        
            <li><a href="/about">About</a></li>
        
    </ul>
</header>
    <div class="main">
        
    <article>
    <h1 class="post-title">
        <span>原来这就是UMD</span>
    </h1>
    <section class="post-content">
        
            
        
        <p>JavaScript在模块化的发展过程中出现和很多概念，比如<a href="http://www.commonjs.org/" target="_blank" rel="noopener">CommonJS</a>，<a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noopener">AMD (Asynchronous Module Definition)</a>，<a href="https://github.com/cmdjs/specification/blob/master/draft/module.md" target="_blank" rel="noopener">CMD (Common Module Definition)</a>等，后来CommonJs规范被Node.js采用，我们可以在Node.js中通过<code>var http = require(&#39;http&#39;)</code>这种写法来引入模块，通过<code>module.exports</code>来导出自定义的模块，AMD和CMD也是requirejs和seajs推广过程中的规范化产出，因此让一个模块可以同时支持这么多的规范，就需要在模块定义时进行判断处理。这个判断处理的代码在流行的库和框架中随处可见，不过今天才知道，其实这种模式叫做<a href="https://github.com/umdjs/umd" target="_blank" rel="noopener">UMD (Universal Module Definition)</a>。<br><a id="more"></a></p>
<p>这个repo规范了UMD API和的定义和实现，让这些模块可以在客户端(浏览器)，服务端或其他地方工作。README里面的一些变体(Variations)规定了各种常规模块的写法，比如<code>amdWeb.js</code>规定了可以运行在AMD规范下(即使用requirejs)和浏览器全局下的模块的写法，点进去会发现其实是一小段示例代码:</p>
<pre><code>(function (root, factory) {
  if (typeof define === &apos;function&apos; &amp;&amp; define.amd) {
    // AMD. Register as an anonymous module.
    define([&apos;b&apos;], factory);
    } else {
      //Browser globals
      root.amdWeb = factory(root.b);
    }
  }(this, function (b) {
    return {};
}));
</code></pre><p>可以看出是一段自执行函数，接收<code>root</code>和<code>factory</code>两个参数，<code>root</code>为全局对象，<code>factory</code>则为工厂函数，用来返回一个模块的实例化对象。这段代码先通过<code>typeof define === &#39;function&#39; &amp;&amp; define.amd</code>来判断当前环境是否遵循AMD规范(因为<code>requirejs</code>和<code>seajs</code>都是使用<code>define</code>来定义模块，所以需要<code>define.amd</code>进一步区分两者)，如果是，通过<code>define([&#39;b&#39;], factory)</code>就可以对模块进行定义，如果不是，就执行<code>root.amdWeb = factory(root.b)</code>，此时<code>root === window</code>，这时window上就挂载了一个factory执行完返回的对象，这个模块就可以全局调用了。</p>
<p>其他的常规模块的定义也都是一个道理，比如<code>returnExports</code>定义了一个在nodejs,AMD,browser global下工作的模块，判断AMD环境仍然是通过<code>typeof define === &#39;function&#39; &amp;&amp; define.amd</code>，判断nodejs环境则通过<code>typeof module === &#39;object&#39; &amp;&amp; module.exports</code>，一般的模块都是判断了所有环境后，如果没有符合条件的就默认为浏览器环境，直接挂在在window上。</p>
<p>JavaScript的世界真是其乐无穷。。。</p>

    </section>
    
        <section id="comments">
        
        </section>
    
</article>

    </div>
    <button class="feedback-btn" data-feedbackok-trigger>Hello~ 🥰</button>
    <footer>
    <div class="info"><span>Powered By <a href="https://hexo.io/" target="blank">Hexo</a></span>&nbsp;&nbsp;&nbsp;&nbsp;<span>Theme by <a href="https://github.com/showonne/hexo_showonne" target="blank">Showonne</a></span></div>
</footer>
    <script src="https://cdn.feedbackok.com/widget.js" data-pid="0m524p3" async defer></script>
    <script src="/js/index.js"></script>
</body>
</html>
