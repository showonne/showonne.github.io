<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
    <title>showonne</title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/styles/tomorrow-night.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
<meta name="generator" content="Hexo 5.4.2"></head>
<body>
    <header>
    <span class="banner"><a href="/">showonne</a></span>
    <span class="menu">Menu</span>
    <ul class="menu_list hide">
        
            <li><a href="/" >Home</a></li>
        
            <li><a href="/archives" >Archives</a></li>
        
            <li><a href="/tags" >Tags</a></li>
        
            <li><a href="/links" >Links</a></li>
        
            <li><a href="/about" >About</a></li>
        
    </ul>
</header>
    <div class="main">
        
    <article>
    <h1 class='post-title'>
        <span>[译]如何使用Rollup打包样式文件并添加LiveReload</span>
    </h1>
    <section class='post-content'>
        
            
        
        <p>通过这个教程学习如何使用JavaScript打包工具Rollup配合PostCSS来取代Grunt或Gulp处理样式文件。</p>
<p>上一篇文章中，我们完成了<a target="_blank" rel="noopener" href="https://code.lengstorf.com/learn-rollup-js/">使用Rollup打包前端JavaScript入门</a>。</p>
<p>这篇文章包含<code>Part II</code>和<code>Part III</code>。</p>
<p><a target="_blank" rel="noopener" href="https://code.lengstorf.com/learn-rollup-css/#stylesheets">Part II</a>会继续在上次的项目中进行，为Rollup添加处理样式的能力，使用PostCSS进行一些转换，让我们能使用更简单的变量写法和嵌套规则等语法糖。</p>
<p>然后完成<a target="_blank" rel="noopener" href="https://code.lengstorf.com/learn-rollup-css/#livereload">Part III</a>，圆满结束。第三部分将为项目添加文件监听和LiveReload，这样每当文件变化时就不用再手动地打包bundle文件了。</p>
<span id="more"></span>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们会在上周的项目基础上继续进行，因此如果你还没有看上一节，推荐你<a target="_blank" rel="noopener" href="https://code.lengstorf.com/learn-rollup-js/">先看一下</a>。</p>
<blockquote>
<p>NOTE: 如果你没有项目的副本，你可以通过这条命令克隆在Part I结束这个状态下的项目：<code>git clone -b part-2-starter --single-branch https://github.com/jlengstorf/learn-rollup.git</code></p>
</blockquote>
<h2 id="Part-II：如何在下一代应用中使用Rollup-js：-PostCSS"><a href="#Part-II：如何在下一代应用中使用Rollup-js：-PostCSS" class="headerlink" title="Part II：如何在下一代应用中使用Rollup.js： PostCSS"></a>Part II：如何在下一代应用中使用Rollup.js： PostCSS</h2><p>你可以轻松地处理CSS并注入到文档的<code>head</code>中，这取决于你的项目如何配置，也是Rollup另一个优点。</p>
<p>另外，所有的构建过程都在一个地方，降低了开发流程的复杂度 - 这对我们很有帮助，尤其是在团队协作时。</p>
<p>不过糟糕的是，我们使得样式依赖JavaScript，并且在无样式HTML在样式注入前会产生一个短暂的闪烁。这对有些项目来说是无法接受的，并且应该通过像使用PostCSS提取等方式解决。</p>
<p>既然这篇文章是关于Rollup的，那么：来吧。让我们使用Rollup！</p>
<h4 id="STEP-0-在main-js中加载样式。"><a href="#STEP-0-在main-js中加载样式。" class="headerlink" title="STEP 0: 在main.js中加载样式。"></a>STEP 0: 在<code>main.js</code>中加载样式。</h4><p>如果你之前从来没用过构建工具，可能感觉这样有点怪，但请跟着我继续。为了在文档中使用样式，我们不会像平常那样使用<code>&lt;link&gt;</code>标签，取而代之，我们将在<code>main.min.js</code>中使用<code>import</code>语句。</p>
<p>现在在<code>src/scripts/main.js</code>开头加载样式：</p>
<pre><code>+ // Import styles (automatically injected into &lt;head&gt;).
+ import &apos;../styles/main.css&apos;;

  // Import a couple modules for testing.
  import &#123; sayHelloTo &#125; from &apos;./modules/mod1&apos;;
  import addArray from &apos;./modules/mod2&apos;;

  // Import a logger for easier debugging.
  import debug from &apos;debug&apos;;
  const log = debug(&apos;app:log&apos;);

  // The logger should only be disabled if we’re not in production.
  if (ENV !== &apos;production&apos;) &#123;

    // Enable the logger.
    debug.enable(&apos;*&apos;);
    log(&apos;Logging is enabled!&apos;);
  &#125; else &#123;
    debug.disable();
  &#125;

  // Run some functions from our imported modules.
  const result1 = sayHelloTo(&apos;Jason&apos;);
  const result2 = addArray([1, 2, 3, 4]);

  // Print the results on the page.
  const printTarget = document.getElementsByClassName(&apos;debug__output&apos;)[0];

  printTarget.innerText = `sayHelloTo(&apos;Jason&apos;) =&gt; $&#123;result1&#125;\n\n`;
  printTarget.innerText += `addArray([1, 2, 3, 4]) =&gt; $&#123;result2&#125;`;
</code></pre><h4 id="STEP-1-安装PostCSS-Rollup插件。"><a href="#STEP-1-安装PostCSS-Rollup插件。" class="headerlink" title="STEP 1: 安装PostCSS Rollup插件。"></a>STEP 1: 安装PostCSS Rollup插件。</h4><p>首先需要Rollup PostCSS插件，使用如下命令安装：</p>
<blockquote>
<p>npm install –save-dev rollup-plugin-postcss</p>
</blockquote>
<h4 id="STEP-2-更新rollup-config-js"><a href="#STEP-2-更新rollup-config-js" class="headerlink" title="STEP 2: 更新rollup.config.js."></a>STEP 2: 更新<code>rollup.config.js</code>.</h4><p>然后，添加插件到<code>rollup.config.js</code>:</p>
<pre><code>  // Rollup plugins
  import babel from &apos;rollup-plugin-babel&apos;;
  import eslint from &apos;rollup-plugin-eslint&apos;;
  import resolve from &apos;rollup-plugin-node-resolve&apos;;
  import commonjs from &apos;rollup-plugin-commonjs&apos;;
  import replace from &apos;rollup-plugin-replace&apos;;
  import uglify from &apos;rollup-plugin-uglify&apos;;
+ import postcss from &apos;rollup-plugin-postcss&apos;;

  export default &#123;
    entry: &apos;src/scripts/main.js&apos;,
    dest: &apos;build/js/main.min.js&apos;,
    format: &apos;iife&apos;,
    sourceMap: &apos;inline&apos;,
    plugins: [
+     postcss(&#123;
+       extensions: [ &apos;.css&apos; ],
+     &#125;),
      resolve(&#123;
        jsnext: true,
        main: true,
        browser: true,
      &#125;),
      commonjs(),
      eslint(&#123;
        exclude: [
          &apos;src/styles/**&apos;,
        ]
      &#125;),
      babel(&#123;
        exclude: &apos;node_modules/**&apos;,
      &#125;),
      replace(&#123;
        ENV: JSON.stringify(process.env.NODE_ENV || &apos;development&apos;),
      &#125;),
      (process.env.NODE_ENV === &apos;production&apos; &amp;&amp; uglify()),
    ],
  &#125;;
</code></pre><h4 id="看一下生成的bundle。"><a href="#看一下生成的bundle。" class="headerlink" title="看一下生成的bundle。"></a>看一下生成的bundle。</h4><p>现在我们已经能够处理样式了，可以看一下新生成的bundle，看看它是如何工作的。</p>
<p>运行<code>./node_modules/.bin/rollup -c</code>，然后看一下生成的<code>build/js/main.min.js</code>，在文件开头几行，可以看到一个名叫<code>__$styleInject()</code>的新函数：</p>
<pre><code>function __$styleInject(css) &#123;
  css = css || &apos;&apos;;
  var head = document.head || document.getElementsByTagName(&apos;head&apos;)[0];
  var style = document.createElement(&apos;style&apos;);
  style.type = &apos;text/css&apos;;
  if (style.styleSheet)&#123;
    style.styleSheet.cssText = css;
  &#125; else &#123;
    style.appendChild(document.createTextNode(css));
  &#125;
  head.appendChild(style);
&#125;
__$styleInject(&quot;/* Styles omitted for brevity... */&quot;);
</code></pre><p>简单地说，这个函数创建了一个<code>&lt;style&gt;</code>元素并设置样式，然后添加到文档的<code>&lt;head&gt;</code>标签中。</p>
<p>就在这个函数声明的下方，可以看到通过传入样式调用该函数，通过PostCSS输出。很酷，不是吗？</p>
<p>但现在这些样式并没有真正地被处理；PostCSS只是直接地传输了我们的样式。让我们添加一些需要的PostCSS插件，使得样式能在目标浏览器上工作。</p>
<h4 id="STEP-3-安装必要的PostCSS插件。"><a href="#STEP-3-安装必要的PostCSS插件。" class="headerlink" title="STEP 3: 安装必要的PostCSS插件。"></a>STEP 3: 安装必要的PostCSS插件。</h4><p>我爱PostCSS。我已经放弃LESS阵营了，当所有人都抛弃LESS时，我发现自己或多或少被影响加入了Sass阵营，后来PostCSS出现了我就非常开心地去学。</p>
<p>我喜欢它是因为它提供了部分在LESS和Sass中我喜欢的功能 - 嵌套，简单的变量 - 而且没有完全放弃LESS和Sass中我认为诱人也危险的功能，比如逻辑运算。</p>
<p>我喜欢它的插件模式，而不是一个叫做“PostCSS”的语言。我们可以只选择真正需要的特性 - 更重要的是，我们可以移除不想要的特性。</p>
<p>因此在我们的项目里，只会使用到四个插件 - 两个是语法糖，一个用来在兼容旧浏览器的新CSS特性，一个用来压缩，减少生成的样式文件大小。</p>
<ul>
<li><p><code>postcss-simple-vars</code> — 可以使用Sass风格的变量(e.g. <code>$myColor: #fff;</code>，<code>color: $myColor;</code>)而不是冗长的CSS语法(e.g. <code>:root &#123;--myColor: #fff&#125;</code>，<code>color: var(--myColor)</code>)。这样更简洁；我更喜欢较短的语法。</p>
</li>
<li><p><code>postcss-nested</code> — 允许使用嵌套规则。实际上我不用它写嵌套规则；我用它简化<a target="_blank" rel="noopener" href="http://getbem.com/naming/">BEM友好的选择器</a>的写法并且划分我的区块，元素和修饰到单个CSS块。</p>
</li>
<li><p><code>postcss-cssnext</code> — 这个插件集使得大多数现代CSS语法(<a target="_blank" rel="noopener" href="https://www.w3.org/Style/CSS/current-work">通过最新的CSS标准</a>)可用，编译后甚至可以在不支持新特性的旧浏览器中工作。</p>
</li>
<li><p><code>cssnano</code> — 压缩，减小输出CSS文件大小。相当于JavaScript中对应的UglifyJS。</p>
</li>
</ul>
<p>使用这个命令安装插件：</p>
<blockquote>
<p>npm install –save-dev postcss-simple-vars postcss-nested postcss-cssnext cssnano</p>
</blockquote>
<h4 id="STEP-4-更新rollup-config-js。"><a href="#STEP-4-更新rollup-config-js。" class="headerlink" title="STEP 4: 更新rollup.config.js。"></a>STEP 4: 更新<code>rollup.config.js</code>。</h4><p>接下来，在<code>rollup.config.js</code>引入PostCSS插件，在配置对象的<code>plugins</code>属性上添加一个<code>postcss</code>。</p>
<pre><code>  // Rollup plugins
  import babel from &apos;rollup-plugin-babel&apos;;
  import eslint from &apos;rollup-plugin-eslint&apos;;
  import resolve from &apos;rollup-plugin-node-resolve&apos;;
  import commonjs from &apos;rollup-plugin-commonjs&apos;;
  import replace from &apos;rollup-plugin-replace&apos;;
  import uglify from &apos;rollup-plugin-uglify&apos;;
  import postcss from &apos;rollup-plugin-postcss&apos;;

+ // PostCSS plugins
+ import simplevars from &apos;postcss-simple-vars&apos;;
+ import nested from &apos;postcss-nested&apos;;
+ import cssnext from &apos;postcss-cssnext&apos;;
+ import cssnano from &apos;cssnano&apos;;

  export default &#123;
    entry: &apos;src/scripts/main.js&apos;,
    dest: &apos;build/js/main.min.js&apos;,
    format: &apos;iife&apos;,
    sourceMap: &apos;inline&apos;,
    plugins: [
      postcss(&#123;
+       plugins: [
+         simplevars(),
+         nested(),
+         cssnext(&#123; warnForDuplicates: false, &#125;),
+         cssnano(),
+       ],
        extensions: [ &apos;.css&apos; ],
      &#125;),
      resolve(&#123;
        jsnext: true,
        main: true,
        browser: true,
      &#125;),
      commonjs(),
      eslint(&#123;
        exclude: [
          &apos;src/styles/**&apos;,
        ]
      &#125;),
      babel(&#123;
        exclude: &apos;node_modules/**&apos;,
      &#125;),
      replace(&#123;
        ENV: JSON.stringify(process.env.NODE_ENV || &apos;development&apos;),
      &#125;),
      (process.env.NODE_ENV === &apos;production&apos; &amp;&amp; uglify()),
    ],
  &#125;;
</code></pre><blockquote>
<p>NOTE: 在<code>cssnext()</code>中配置了<code>&#123; warnForDuplicates: false &#125;</code>是因为它和<code>cssnano()</code>都使用了<a target="_blank" rel="noopener" href="https://github.com/postcss/autoprefixer">Autoprefixer</a>，会导致一个警告。不用计较配置, 我们只需要知道它被执行了两次(在这个例子中没什么坏处)并且取消了警告。</p>
</blockquote>
<h4 id="检查-lt-head-gt-中的输出内容。"><a href="#检查-lt-head-gt-中的输出内容。" class="headerlink" title="检查&lt;head&gt;中的输出内容。"></a>检查<code>&lt;head&gt;</code>中的输出内容。</h4><p>插件安装完后，重新构建bundle文件。(<code>./node_modules/.bin/rollup -c</code>)，然后在浏览器中打开<code>build/index.html</code>。可以看到页面是有样式的，如果我们审查元素可以发现样式被注入到页面头部，压缩简化，添加所有浏览器前缀和其它我们预期的优点：</p>
<blockquote>
<p>样式被PostCSS处理并通过Rpllup注入</p>
</blockquote>
<p>太棒了！我们现在拥有十分可靠的构建流程：JavaScript会被打包，无用的代码会被移除，输出文件是经过压缩精简的，样式时通过PostCSS处理后注入到文档头部的。</p>
<p>然而，最后仍然存在一个痛点，每当我们做了一些修改后都不得不手动地重新构建。因此在下个部分，我们让Rollup监听文件的变化，每当有文件改变时就让浏览器自动重新载入文件。</p>
<h2 id="Part-III-如何在下一代应用中使用Rollup-js：实时加载"><a href="#Part-III-如何在下一代应用中使用Rollup-js：实时加载" class="headerlink" title="Part III: 如何在下一代应用中使用Rollup.js：实时加载"></a>Part III: 如何在下一代应用中使用Rollup.js：实时加载</h2><p>现在，我们的项目已经可以打包JavaScript和样式文件了，但仍然是一个手动的过程。而且由于过程的每个步骤都是手动的，相比自动化流程失败风险更高 - 因为每次修改文件后都执行<code>./node_modules/.bin/rollup -c</code>太痛苦了 - 我们希望自动重新构建bundle。</p>
<blockquote>
<p>NOTE: 如果你没有项目的副本，你可以通过这条命令克隆在Part II结束这个状态下的项目：: <code>git clone -b part-3-starter --single-branch https://github.com/jlengstorf/learn-rollup.git</code></p>
</blockquote>
<h4 id="STEP-0-为Rollup添加监听插件。"><a href="#STEP-0-为Rollup添加监听插件。" class="headerlink" title="STEP 0: 为Rollup添加监听插件。"></a>STEP 0: 为Rollup添加监听插件。</h4><p>基于Node.js的监听器是很常见的开发工具。如果你之前使用过webpack，Grunt，Gulp或者其他构建工具会很熟悉。</p>
<p>监听器是在一个项目中运行的进程，当你修改了它监听的文件夹内的任意文件时就会触发一个动作。对于构建工具而言，通常这个动作是触发重新构建。</p>
<p>在我们的项目中，我们需要监听<code>src</code>目录下的任何文件，并且探测到文件变化后希望Rollup重新打包。</p>
<p>为了达到目的，我们使用<a target="_blank" rel="noopener" href="https://github.com/rollup/rollup-watch"><code>rollup-watch</code></a>插件，它和前面的其它Rollup插件有些不同 - but more on that in a bit。让我们先安装插件：</p>
<pre><code>npm install --save-dev rollup-watch
</code></pre><h4 id="STEP-1-传入-watch标识运行Rollup。"><a href="#STEP-1-传入-watch标识运行Rollup。" class="headerlink" title="STEP 1: 传入--watch标识运行Rollup。"></a>STEP 1: 传入<code>--watch</code>标识运行Rollup。</h4><p><code>rollup-watch</code>与其他插件的不同就是使用这个插件不需要对<code>rollup.config.js</code>做任何修改。</p>
<p>取而代之的是，在终端命令中添加一个标识：</p>
<pre><code># Run Rollup with the watch plugin enabled
./node_modules/.bin/rollup -c --watch
</code></pre><p>运行完后，可以发现控制台的输出和之前有点不同：</p>
<pre><code>$ ./node_modules/.bin/rollup -c --watch
checking rollup-watch version...
bundling...
bundled in 949ms. Watching for changes...
</code></pre><p>这个进程依然保持活动状态，正在监听变化。</p>
<p>如果我们在<code>src/main.js</code>做点小变化 - 比如加一条注释 - 在我们保存修改的那一刻新的bundle文件就生成了。</p>
<blockquote>
<p>监听程序执行时，变化会触发重新构建。LINTER会立刻捕获错误。很优雅，不是吗？</p>
</blockquote>
<p>这为我们在开发过程中节省了大量时间，不过还可以更进一步。现在我们仍然需要手动刷新浏览器来获取更新后的bundle - 添加一个工具，在bundle更新后自动刷新浏览器。</p>
<blockquote>
<p>TIP: 在终端窗口输入<code>control + C</code>结束监听进程。</p>
</blockquote>
<h4 id="STEP-2-安装Liveload自动刷新浏览器。"><a href="#STEP-2-安装Liveload自动刷新浏览器。" class="headerlink" title="STEP 2: 安装Liveload自动刷新浏览器。"></a>STEP 2: 安装Liveload自动刷新浏览器。</h4><p><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/livereload">LiveReload</a>是加速开发的常用工具。它是一个跑在后台的进程，每当有它监听的文件变化时，他就会通知浏览器刷新。</p>
<p>先下载插件：</p>
<pre><code>npm install --save-dev livereload
</code></pre><h4 id="STEP-3-注入livereload脚本。"><a href="#STEP-3-注入livereload脚本。" class="headerlink" title="STEP 3: 注入livereload脚本。"></a>STEP 3: 注入livereload脚本。</h4><p>In <code>src/main.js</code>, add the following:</p>
<p>在LiveReload工作前，需要向页面中注入一段脚本用于和LiveReload的服务器建立连接。</p>
<p>不过只有开发环境下有这个需求，利用环境变量的能力判断只有在非生产环境下才注入脚本。</p>
<p>在<code>src/main.js</code>中添加下面代码：</p>
<pre><code>  // Import styles (automatically injected into &lt;head&gt;).
  import &apos;../styles/main.css&apos;;

  // Import a couple modules for testing.
  import &#123; sayHelloTo &#125; from &apos;./modules/mod1&apos;;
  import addArray from &apos;./modules/mod2&apos;;

  // Import a logger for easier debugging.
  import debug from &apos;debug&apos;;
  const log = debug(&apos;app:log&apos;);

  // The logger should only be disabled if we’re not in production.
  if (ENV !== &apos;production&apos;) &#123;

    // Enable the logger.
    debug.enable(&apos;*&apos;);
    log(&apos;Logging is enabled!&apos;);

+   // Enable LiveReload
+   document.write(
+     &apos;&lt;script src=&quot;http://&apos; + (location.host || &apos;localhost&apos;).split(&apos;:&apos;)[0] +
+     &apos;:35729/livereload.js?snipver=1&quot;&gt;&lt;/&apos; + &apos;script&gt;&apos;
+   );
  &#125; else &#123;
    debug.disable();
  &#125;

  // Run some functions from our imported modules.
  const result1 = sayHelloTo(&apos;Jason&apos;);
  const result2 = addArray([1, 2, 3, 4]);

  // Print the results on the page.
  const printTarget = document.getElementsByClassName(&apos;debug__output&apos;)[0];

  printTarget.innerText = `sayHelloTo(&apos;Jason&apos;) =&gt; $&#123;result1&#125;\n\n`;
  printTarget.innerText += `addArray([1, 2, 3, 4]) =&gt; $&#123;result2&#125;`;
</code></pre><p>做一些修改然后保存，现在我们试试看。</p>
<blockquote>
<p>NOTE: Livereload是如何工作的并不重要，简单的解释就是命令行进程监听文件变化，然后通过websockets向客户端脚本发送消息触发重加载。</p>
</blockquote>
<h4 id="STEP-4-运行Livereload。"><a href="#STEP-4-运行Livereload。" class="headerlink" title="STEP 4: 运行Livereload。"></a>STEP 4: 运行Livereload。</h4><p>LiveReload安装好并且脚本注入到文档中后，我们可以运行它去监听<code>build</code>目录：</p>
<pre><code>./node_modules/.bin/livereload &apos;build/&apos;
</code></pre><blockquote>
<p>NOTE: 监听<code>build/</code>是因为我们只需要在新的bundle产生时才重新构建。</p>
</blockquote>
<p>输出结果像下面这样：</p>
<pre><code>$ ./node_modules/.bin/livereload &apos;build/&apos;
Starting LiveReload v0.5.0 for /Users/jlengstorf/dev/code.lengstorf.com/projects/learn-rollup/build on port 35729.
</code></pre><p>如果我们用浏览器打开<code>build/index.html</code> - 务必在开启LiveReload后再刷新页面，确保socket连接处于激活状态 - 可以发现<code>build/index.html</code>的变化会让浏览器自动重新加载：</p>
<blockquote>
<p>文件变化触发浏览器重新加载。</p>
</blockquote>
<p>非常棒，但仍然不完美：现在我们只能运行Rollup的监听函数或者LiveReload，除非我们打开多个终端会话。这可不理想。接下来我们会选择一个解决办法。</p>
<p>STEP 5: 使用<code>package.json</code>脚本简化启动过程。</p>
<p>教程至今，我们都不得不输入<code>rollup</code>脚本的全路径，我猜你已经感觉到这很蠢了。</p>
<p>因此我们需要一个能同时运行监听任务和<code>Livereload</code>的工具，先将这两个<code>rollup</code>命令和LiveReload命令当做脚本写在<code>package.json</code>中。</p>
<p>打开<code>package.json</code> - 它位于项目根目录。在这个文件里能看到如下内容：</p>
<pre><code>&#123;
  &quot;name&quot;: &quot;learn-rollup&quot;,
  &quot;version&quot;: &quot;0.0.0&quot;,
  &quot;description&quot;: &quot;This is an example project to accompany a tutorial on using Rollup.&quot;,
  &quot;main&quot;: &quot;build/js/main.min.js&quot;,
  &quot;scripts&quot;: &#123;
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  &#125;,
  &quot;repository&quot;: &#123;
    &quot;type&quot;: &quot;git&quot;,
    &quot;url&quot;: &quot;git+ssh://git@github.com/jlengstorf/learn-rollup.git&quot;
  &#125;,
  &quot;author&quot;: &quot;Jason Lengstorf &lt;jason@lengstorf.com&gt; (@jlengstorf)&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;bugs&quot;: &#123;
    &quot;url&quot;: &quot;https://github.com/jlengstorf/learn-rollup/issues&quot;
  &#125;,
  &quot;homepage&quot;: &quot;https://github.com/jlengstorf/learn-rollup#readme&quot;,
  &quot;devDependencies&quot;: &#123;
    &quot;babel-preset-es2015-rollup&quot;: &quot;^1.2.0&quot;,
    &quot;cssnano&quot;: &quot;^3.7.4&quot;,
    &quot;livereload&quot;: &quot;^0.5.0&quot;,
    &quot;npm-run-all&quot;: &quot;^3.0.0&quot;,
    &quot;postcss-cssnext&quot;: &quot;^2.7.0&quot;,
    &quot;postcss-nested&quot;: &quot;^1.0.0&quot;,
    &quot;postcss-simple-vars&quot;: &quot;^3.0.0&quot;,
    &quot;rollup&quot;: &quot;^0.34.9&quot;,
    &quot;rollup-plugin-babel&quot;: &quot;^2.6.1&quot;,
    &quot;rollup-plugin-commonjs&quot;: &quot;^3.3.1&quot;,
    &quot;rollup-plugin-eslint&quot;: &quot;^2.0.2&quot;,
    &quot;rollup-plugin-node-resolve&quot;: &quot;^2.0.0&quot;,
    &quot;rollup-plugin-postcss&quot;: &quot;^0.1.1&quot;,
    &quot;rollup-plugin-replace&quot;: &quot;^1.1.1&quot;,
    &quot;rollup-plugin-uglify&quot;: &quot;^1.0.1&quot;,
    &quot;rollup-watch&quot;: &quot;^2.5.0&quot;
  &#125;,
  &quot;dependencies&quot;: &#123;
    &quot;debug&quot;: &quot;^2.2.0&quot;
  &#125;
&#125;
</code></pre><p>看到<code>scripts</code>属性了吗？我们将为它增加两个新属性：</p>
<ul>
<li><p>一个运行Rollup打包的脚本(原先手动执行的<code>./node_modules/.bin/rollup -c --watch</code>)</p>
</li>
<li><p>一个启动LiveReload的脚本(原先手动执行的<code>./node_modules/.bin/livereload &#39;build/&#39;</code>)</p>
</li>
</ul>
<p>在<code>package.json</code>加上下面的内容：</p>
<pre><code>  &#123;
&quot;name&quot;: &quot;learn-rollup&quot;,
&quot;version&quot;: &quot;0.0.0&quot;,
&quot;description&quot;: &quot;This is an example project to accompany a tutorial on using Rollup.&quot;,
&quot;main&quot;: &quot;build/js/main.min.js&quot;,
&quot;scripts&quot;: &#123;
+     &quot;dev&quot;: &quot;rollup -c --watch&quot;,
+     &quot;reload&quot;: &quot;livereload &apos;build/&apos;&quot;,
      &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
    &#125;,
    &quot;repository&quot;: &#123;
      &quot;type&quot;: &quot;git&quot;,
      &quot;url&quot;: &quot;git+ssh://git@github.com/jlengstorf/learn-rollup.git&quot;
    &#125;,
    &quot;author&quot;: &quot;Jason Lengstorf &lt;jason@lengstorf.com&gt; (@jlengstorf)&quot;,
    &quot;license&quot;: &quot;ISC&quot;,
    &quot;bugs&quot;: &#123;
      &quot;url&quot;: &quot;https://github.com/jlengstorf/learn-rollup/issues&quot;
    &#125;,
    &quot;homepage&quot;: &quot;https://github.com/jlengstorf/learn-rollup#readme&quot;,
    &quot;devDependencies&quot;: &#123;
      &quot;babel-preset-es2015-rollup&quot;: &quot;^1.2.0&quot;,
      &quot;cssnano&quot;: &quot;^3.7.4&quot;,
      &quot;livereload&quot;: &quot;^0.5.0&quot;,
      &quot;npm-run-all&quot;: &quot;^3.0.0&quot;,
      &quot;postcss-cssnext&quot;: &quot;^2.7.0&quot;,
      &quot;postcss-nested&quot;: &quot;^1.0.0&quot;,
      &quot;postcss-simple-vars&quot;: &quot;^3.0.0&quot;,
      &quot;rollup&quot;: &quot;^0.34.9&quot;,
      &quot;rollup-plugin-babel&quot;: &quot;^2.6.1&quot;,
      &quot;rollup-plugin-commonjs&quot;: &quot;^3.3.1&quot;,
      &quot;rollup-plugin-eslint&quot;: &quot;^2.0.2&quot;,
      &quot;rollup-plugin-node-resolve&quot;: &quot;^2.0.0&quot;,
      &quot;rollup-plugin-postcss&quot;: &quot;^0.1.1&quot;,
      &quot;rollup-plugin-replace&quot;: &quot;^1.1.1&quot;,
      &quot;rollup-plugin-uglify&quot;: &quot;^1.0.1&quot;,
      &quot;rollup-watch&quot;: &quot;^2.5.0&quot;
    &#125;,
    &quot;dependencies&quot;: &#123;
      &quot;debug&quot;: &quot;^2.2.0&quot;
    &#125;
  &#125;
</code></pre><p>这些脚本让我们可以使用简称来执行选择的脚本。</p>
<p>使用<code>npm run dev</code>运行Rollup。</p>
<p>使用<code>npm run reload</code>执行LiveReload。</p>
<p>接下来要做的就是让他们一起运行。</p>
<h4 id="STEP-6-安装同时运行watcher和Livereload的工具。"><a href="#STEP-6-安装同时运行watcher和Livereload的工具。" class="headerlink" title="STEP 6: 安装同时运行watcher和Livereload的工具。"></a>STEP 6: 安装同时运行watcher和Livereload的工具。</h4><p>为了能同时执行Rollup和LiveReload，我们要使用一个叫做<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/npm-run-all"><code>npm-run-all</code></a>的工具。</p>
<p>这是一个强大的工具，我们先不讨论他的全部功能。我们现在只使用它并行执行脚本的能力 - 意味着同一个终端会话可以同时执行两个任务。</p>
<p>先安装<code>npm-run-all</code>:</p>
<pre><code>npm install --save-dev npm-run-all
</code></pre><p>然后我们要在<code>package.json</code>中再加入一条调用<code>npm-run-all</code>的脚本。在<code>scripts</code>代码块内，添加如下内容(简单起见我省略了文件的大部分内容)：</p>
<pre><code>    &quot;scripts&quot;: &#123;
      &quot;dev&quot;: &quot;rollup -c --watch&quot;,
      &quot;reload&quot;: &quot;livereload &apos;build/&apos; -d&quot;,
+     &quot;watch&quot;: &quot;npm-run-all --parallel reload dev&quot;,
      &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
    &#125;
</code></pre><p>保存修改，切换到终端。准备好最后一步！</p>
<h4 id="STEP-7-执行最后的watch脚本。"><a href="#STEP-7-执行最后的watch脚本。" class="headerlink" title="STEP 7: 执行最后的watch脚本。"></a>STEP 7: 执行最后的<code>watch</code>脚本。</h4><p>就像之前做的一样。</p>
<p>在终端中运行下面的命令：</p>
<pre><code>npm run watch
</code></pre><p>然后刷新浏览器, 改变一下JS或CSS, 浏览器会加载更新后的bundle并自动刷新 - 太奇妙了！</p>
<blockquote>
<p>Liveload + 自动构建如同魔法一般。</p>
</blockquote>
<p>现在我们是Rollup专家了。我们的打包代码变得更小更快，开发流程也更轻松快速。</p>
<h2 id="Further-Reading"><a href="#Further-Reading" class="headerlink" title="Further Reading"></a>Further Reading</h2><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p><a target="_blank" rel="noopener" href="http://postcss.org/">PostCSS</a></p>
<p><a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/26882177/react-js-inline-style-best-practices">Some discussion about using JS to insert styles, and when/whether it’s appropriate</a></p>
<p>这篇文章的代码放在GitHub上。你可以<a target="_blank" rel="noopener" href="https://github.com/jlengstorf/learn-rollup">fork 这个仓库</a>进行修改或测试，<a target="_blank" rel="noopener" href="https://github.com/jlengstorf/learn-rollup/issues">开issue</a>或者报告bug，或者<a target="_blank" rel="noopener" href="https://github.com/jlengstorf/learn-rollup/compare">新建pull request</a>进行建议或者修改。</p>
<p><a target="_blank" rel="noopener" href="https://code.lengstorf.com/learn-rollup-css/">原文链接</a></p>

    </section>
    
        <section id="comments">
        
        </section>
    
</article>

    </div>
    <button class="feedback-btn" data-feedbackok-trigger>Hello~ 🥰</button>
    <footer>
    <div class="info"><span>Powered By <a href="https://hexo.io/" target="blank">Hexo</a></span>&nbsp;&nbsp;&nbsp;&nbsp;<span>Theme by <a href="https://github.com/showonne/hexo_showonne" target="blank">Showonne</a></span></div>
</footer>
    <script
        src="https://cdn.feedbackok.com/widget.js"
        data-pid="0m524p3"
        async
        defer
    ></script>
    
<script src="/js/index.js"></script>

</body>
</html>
